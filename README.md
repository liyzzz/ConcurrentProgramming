# ConcurrentProgramming
并发编程
## 多线程基础
多线程基础示例都在base包下
### 多线程有什么好处
为了使CPU资源充分利用，当某个作业因为I/O而阻塞时，CPU可以执其他作业提高效率
### 异步,同步，并行，并发，串行
**同步**：多个任务情况下，一个任务A执行结束，才可以执行另一个任务B。只存在一个线程。  
**异步**：多个任务情况下，一个任务A正在执行，同时可以执行另一个任务B。任务B不用等待任务A结束才执行。存在多条线程。   
而**并发**和**并行**其实是**异步线程**实现的两种形式，**串行**是**同步线程**的实现方式  
**并行**（多核CPU,且cpu分配线程在不同核执行）：真正意义上的同时，执行A任务的同时执行多任务  
**并发**（单核CPU,或CPU分配线程在同一核执行）：从微观层面上看，并发是在一条CPU上不停的切换任务。比如任务A执行了20%，任务A停下里，线程让给任务B，任务执行了30%停下，再让任务A执行。这样我们用的时候，由于CUP处理速度快，
所以从宏观上看起来好像是同时执行，其实并不是的，同一时间只会执行单个任务  
**串行**：任务有顺序的执行，必须等前一个任务执行完才能执行下一个任务
### 线程和进程区别
系统会按进程来分配资源；线程是CPU调度的基本单位不可独立执行；  
进程可以拥有系统资源；而线程基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),
但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源；

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配
### java内存模型和线程的关系
堆在多线程中是共享的，而栈是每个线程独享的
### 线程的实现方式
1.实现Runnable接口（示例见：MyRunnable）   
2.继承Tread类（示例见：MyThread）  
3.实现 Callable接口（示例见：MyCallable）
### 线程的六种状态
博文[Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651) 总结很好，不再赘述   
示例代码见ThreadStatusDemo类
### 如何查看某个线程栈日志：
```
找见class文件，在该目录下运行cmd  
输入命令：jsp              查看所有运行的java线程和线程的Id  
再输入:jstack 线程ID       查看该线程的栈日志 
```
### 如何查看native方法的源码
以openJDK为例，openJDK采用hotspot虚拟机  
http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/00cd9dc3c2b5/src/share/native/java/lang/Thread.c  
上面的网址可以找到java源码中的native方法于hotspot的映射关系  
根据此映射关系在hotspot源码中查找 
### run方法和start方法区别
start方法是一个信号，告诉cpu我准好了，可以执行了；  
而run方法是线程具体需要的执行的逻辑   
start方法最终回调了run方法 
### InterruptedException
这个异常的意思是表示**一个阻塞被其他线程中断**了。  

为什么 Object.wait、Thread.sleep 和 Thread.join都会抛出InterruptedException? 
  
这几个方法有一个共同点，都是属于阻塞的方法，  
而阻塞方法的释放会取决于一些外部的事件,但是阻塞方法可能因为等不到外部的触发事件而导致一直阻塞，所以它允许一个线程请求自己来停止它正在做的事情。  
当一个方法抛出 InterruptedException 时，它是在告诉调用者如果执行该方法的线程被中断， 
它会尝试停止正在做的事情并且通过抛出 InterruptedException 表示提前返回。    
由于线程调用了 interrupt()中断方法，那么Object.wait、Thread.sleep 等被**阻塞的线程被唤醒**以后会通过is_interrupted 方法判断中断标识的状态变化，  
如果发现中断标识为 true，则**先清除中断标识**(设置为false)，然后抛出InterruptedException，**线程继续运行**     
具体的示例代码见InterruptedExceptionDemo
### 线程安全
#### 什么是线程安全
一个对象是否是线程安全的，取决于它是否会被多个线程
访问，以及程序中是如何去使用这个对象的。如果
多个线程访问同一个共享对象，在不需额外的同步以及调
用端代码不用做其他协调的情况下，这个共享对象的状态
依然是正确的（正确性意味着这个对象的结果与我们预期
规定的结果保持一致），那说明这个对象是线程安全的。  
示例代码见SecurityDemo

解决线程安全的方式通常是加锁
#### java中锁分类
美团有一篇技术博客总结的非常好：[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)  
这里不再赘述
### 什么CAS
参见博文[面试必问的CAS，你懂了吗？](https://zhuanlan.zhihu.com/p/34556594)  
CAS的全程是 compare and swap 从名字就可以看出来，他做了比较并替换  
该算法有三个参数：1、内存值V；2.旧的预期值A 3.即将更新的值B  
当且仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。
其伪代码如下：
```
if(this.value == A){
    this.value = B
    return true;
}else{
    return false;
}
```
CAS的问题：  
1.循环时间长开销很大  
2.只能针对一个共享变量   
3.ABA 问题（如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变就会做替换操作，但是实质上它已经发生了改变）
### Synchronized


